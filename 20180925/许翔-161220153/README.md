# Java程序设计 第3次作业 更新 v4

###### 161220153 许翔

本次提交是完成大作业过程中的一次性的阶段性提交。相比于第三次提交，这次做了如下改动：

- 引入图形化界面，基于javafx图形化框架。

- 初步实现文件I/O，可以读取和存储生物体的移动记录。这部分还处在非常初步的阶段。提交的文件中附带了一个history.txt，可以用作测试。

- 初步实现键盘I/O，可以通过L和S键加载或保存记录。

- “造物主”角色改为Controller，其一方面延续了之前Coordinator的任务，另一方面也由于javafx框架的引入而负责界面的加载和显示、文件的加载和保存、游戏记录的回放、键盘输入的响应等。

# Java程序设计 第3次作业 更新 v3

###### 161220153 许翔

相比于第二次提交，这次做了如下改动：

- 引入泛型和容器。具体的：

- 数组均使用ArrayList容器，其中的遍历使用Iterator的相关操作来完成。

- 将负责“放置加油助威的老爷爷/蛇精”函数修改成泛型函数，这个“放置”功能应该由造物主来完成，所以它是造物主的一个成员函数。

- 此外，还对“造物主”Coordinator的内容进行了一定修改，相比于原来直接在main函数中进行相关操作，现在需要生成一个Coordinator的实例，再进行相关操作。

# Java程序设计 第3次作业 更新 v2

###### 161220153 许翔

相比于第一次提交，这次做了如下改动：

- 删除了葫芦娃多具有的属性和方法（这些方法主要源于直接复用了第2次作业的代码，现在予以删除）。

- “打印”不应该是生物体具备的功能，因此将“打印”方法从生物体中去除，而是交给地图去打印。

- 调整了几个类之间的关系，特别是地图类和阵型类的关系。以前是阵型类中含有地图类的实例，现在将两个类的关系并列。

- 打印阵型的相关函数改为static类型。这样避免了初始化一个阵型类实例的过程，这个类的实例实际上并没有什么作用。

- 老爷爷和蛇精为各自阵营加油助阵这个功能应该是老爷爷或者蛇精自身具有的能力，因此这两个功能改为这两个生物体下的方法。

- 葫芦娃的颜色、生物体的名称改为了枚举类型。

# Java程序设计 第3次作业

###### 161220153 许翔

> 作业要求：以文字说明所写代码中用到哪些面向对象的概念、机制、设计理念等，并阐述这样做的好处

1. 涉及到葫芦娃、老爷爷、蛇精、蝎子精、小喽啰等多种生物体，因此很自然地使用**继承**，有一个“生物体”父类，以及不同生物体的子类。父类有着一些共通的属性，例如名称、所在位置横纵坐标以及一些共同的方法。不过这些属性和方法都源于第2次作业，在这一次作业中目前还没有使用。

使用**继承**，可以让一些具有共同特点的类型在拥有相同的数据成员和成员函数的同时，还可以定义自己特有的数据成员和成员函数。这样，一方面，它们的共通部分只需要编写一次代码，节省了开发时间和维护成本；另一方面，允许他们定义新的成员，保证了不同类型的特点可以体现。

```java
public class Creature {
  protected String name; //共通属性
  protected int positionX;
  protected int positionY;
  ...
  public void changePosition(int x, int y){ ... } //共通方法
}

class CalabashBros extends Creature{
  private int number; //葫芦娃特有的属性，比如它们具有颜色、他们具有一个顺序关系
  private String color;
  ...
}

class GrandFather extends Creature{ ... } //其他生物体同理
```

不同的阵型，我是通过不同函数来实现的。基于现有的这种继承关系，我可以很方便地将阵型函数的调用接口的其中一个参数类型设为Creature类，这样不管是葫芦娃，还是蝎子精小喽啰，都可以通过同样的函数来实现阵型的排列。例如：

```java
public boolean HeYi(Creature creature[], int leadX, int leadY, String direction){ ... }
```

对于葫芦娃，就可以直接排列阵型：

```java
CalabashBros[] calabashBros = { new CalabashBros(0), ... , new CalabashBros(6), };
formation.ChangShe(calabashBros, 8, 10, "Left");
```

对于蝎子精小喽啰，由于蝎子精和小喽啰本身不属于同一类型，但是类型的父类都是Creature类，因此可以在组合后排列阵型：

```java
Scorpion scorpion = new Scorpion();
Underling[] underling = { new Underling(0), ... , new Underling(6),  };
Creature[] badGuys = new Creature[underling.length+1];
badGuys[0] = scorpion;
System.arraycopy(underling, 0, badGuys, 1, underling.length);
formation.HeYi(badGuys, 11, 10, "Right");
```

2. 我们要在最后输出整个二维空间，每种生物体应该输出不同的符号代表自身，但是“输出”这个方法是共通的，因此用到了**多态**。在“生物体”基类中定义了一个print方法，而不同生物体的子类override这一方法，来输出自身的符号。

使用**多态**，可以统一相近类型（即具有相同父类的子类）的方法调用的接口，且不影响体现子类自身的特殊性。

3. 在整个面向对象的程序设计的过程中，都贯穿着**数据抽象**这一思想。

在我的实现中，Coordinator担任“造物主”这一角色，具有整个程序的main函数。阵型是在二维空间上实现的，因此我将代表二维空间的Map类作为了阵型的Formation类的成员变量。造物主可以通过调用阵型类提供的不同函数（即不同阵型），传递不同参数（即安排不同的生物体、阵型所在位置）来达到排布阵型的效果。

Map类本身“管理”着一个二维空间，用一个私有成员二维数组来实现，数组的类型是Creature，当某一个位置有生物体时，二维数组的对应位置就会存储该生物体的引用，可以理解为指向了这个生物体，否则就存储一个NULL。Map类还提供放置生物、移除生物、打印二维空间的方法接口。

一些思考：

1. 在对不同生物体进行抽象时，面临了一个选择。如果葫芦娃这个类型继承于生物体，那么葫芦娃就无法用枚举类型来实现，因为Java不支持多继承，而ENUM本身是通过继承来实现的。如果葫芦娃使用枚举类型，他就无法继承于生物体这一类型，那么其他的像老爷爷、蝎子精这些角色是单独成类型还是继承自生物体类型，也面临一个选择。最终，我选择了放弃枚举类型而将所有角色都继承于生物体这一父类，来保持整体的统一，并便于阵型函数调用的实现。

2. 在对“阵型”进行抽象的时候，也面临了一个选择，是把不同阵型都抽象成不同的类型，还是只是为不同阵型提供不同的方法函数。我目前采取的是后者的实现方法，我暂时没能比较出两种实现哪个更好。
